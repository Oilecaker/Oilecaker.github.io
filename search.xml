<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>电工实习的~作业</title>
    <url>/2020/03/31/%E7%94%B5%E5%B7%A5%E5%AE%9E%E4%B9%A0%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<hr>
<h1 id="protel的安装"><a href="#protel的安装" class="headerlink" title="protel的安装"></a>protel的安装</h1><ol>
<li>下载压缩文件”proteldxp.rar”<br><img src="/images/pasted-1.png" alt="upload successful"></li>
<li>解压后有a和b两个文件夹<br><img src="/images/pasted-2.png" alt="upload successful">  </li>
</ol>
<p>&emsp;&emsp;2.1 <font face="黑体" color="red">a文件夹</font>，<font color="gray">安装DXP 2004</font> </p>
<p>&emsp;&emsp;a文件夹 -&gt; Setup文件夹 -&gt; Setup.exe(管理员身份运行！)，一路默认安装过去（可以更改安装路径） </p>
<p>&emsp;&emsp;2.2 <font face="黑体" color="red">b文件夹</font>，<font color="gray">补丁，元件库 与 DXP破解</font>  </p>
<p>&emsp;&emsp;&emsp;2.2.1  <font color="black"> 补丁，元件库</font><br>&emsp;&emsp;&emsp;分别运行b文件中的 DXP2004SP2.exe (补丁)和 DXP2004SP2_IntegratedLibraries.exe (元件库)文件<br>&emsp;&emsp;&emsp;(不用管parallel port的错误）<br><img src="/images/pasted-4.png" alt="upload successful"></p>
<p>&emsp;&emsp;&emsp;2.2.2  <font color="black"> 破解 </font><br>&emsp;&emsp;&emsp;b文件夹-&gt; DXP2004crack -&gt;Protel2004破解 -&gt;Protel 2004 SP2 keygen 按照AltiumDXP2004SP2KeyGen.exe内部的教程可以进行破解。</p>
<hr>
<h1 id="PCB板制作"><a href="#PCB板制作" class="headerlink" title="PCB板制作"></a>PCB板制作</h1><ol>
<li>设计-&gt;层堆栈管理器-&gt;菜单-&gt;图层堆栈范例-&gt;单层<br>&emsp;&emsp;改完下面层分布栏会变成，Solder Side就是Bottom Side<br><img src="/images/pasted-9.png" alt="upload successful"></li>
<li>改单位计量，查看-&gt;切换单位</li>
<li>在Mechanical 1层画51mm×80mm矩形范围。(粉红色的线)</li>
<li>取消短接，设计-&gt;规则-&gt;Electrical-&gt;Short-Circuit，取消勾选<br><img src="/images/pasted-10.png" alt="upload successful"></li>
<li>切换到SolderSide层，在右侧元件库按照封装名选择元件，然后添加到工作区。<br><img src="/images/pasted-11.png" alt="upload successful"></li>
</ol>
<p><img src="/images/pasted-12.png" alt="upload successful"><br>6. 现在可以开始连线了！<br>&emsp;-旋转元件：长按元件+空格。<br>&emsp;-连线，不能成锐角和直角。<br>&emsp;-二极管，有横线的一端是负极<br>&emsp;-三极管，1端是箭头流出端<br>&emsp;-焊盘形状，方形为正极，圆形为负极<br>&emsp;-走线，不能交叉<br>&emsp;-焊盘，一些接地右键属性，改标识符GND<br>7. <font color="red">连接器</font>我统一放在下面一排（K1，K2，K3，电源V，电动机M<br>8. 连线完，放置-&gt;字符串,把 <font color="red">学号</font> 放在PCB板左下角。</p>
<hr>
<h1 id="最后成果图"><a href="#最后成果图" class="headerlink" title="最后成果图"></a>最后成果图</h1><hr>
<p><img src="/images/pasted-13.png" alt="upload successful"></p>
]]></content>
      <categories>
        <category>大学课程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/31/Hello-World/</url>
    <content><![CDATA[<h2 id="Begin-blogging-process…"><a href="#Begin-blogging-process…" class="headerlink" title="Begin blogging process…"></a>Begin blogging process…</h2>]]></content>
  </entry>
  <entry>
    <title>地图分析</title>
    <url>/2020/04/06/%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<hr>
<h1 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述</strong>：</h1><p>你现在手里有一份大小为 N x N 的「地图」（网格） grid，上面的每个「区域」（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。</p>
<p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。</p>
<p>如果我们的地图上只有陆地或者海洋，请返回 -1。</p>
<hr>
<h1 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a><strong>问题分析</strong>：</h1><ol>
<li>创建一个N×N随机二维容器（考虑Vector容器），创建地图。  </li>
<li>得到地图中所有值为1的索引值xIndex,yIndex。</li>
<li>changeVector，将值为1的元素，在上下左右进行扩展，如果周围四格中元素值为0，则将其值变为1，得到新地图。</li>
<li>将新地图继续执行第3步，直到所有的值为1，并且声明一个计数值counter，记录执行第3步的次数。</li>
<li>counter值即为最大距离maxDistance。 </li>
</ol>
<hr>
<h1 id="C-代码："><a href="#C-代码：" class="headerlink" title="C++代码："></a><strong>C++代码</strong>：</h1><ol>
<li><p><em>先生成一维随机vector</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void createRamdomVector(vector&lt;int&gt;&amp; obj)&#x2F;&#x2F;产生存储随机0，1的一维随机vector容器</span><br><span class="line">    &#123;</span><br><span class="line">        int size &#x3D; obj.size();&#x2F;&#x2F;得到Vector的大小</span><br><span class="line">        obj.clear();&#x2F;&#x2F;每次清除暂存数据的vector，初始化</span><br><span class="line">        &#x2F;&#x2F;srand((int)(time(NULL)));随机种子生成函数</span><br><span class="line">        for (int i &#x3D; 0; i&lt;size; ++i)&#x2F;&#x2F;插入0，1</span><br><span class="line">        &#123;	</span><br><span class="line">            int randnum &#x3D; rand() % 2;</span><br><span class="line">            obj.push_back(randnum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> <strong>出现问题：</strong>随机种子生成函数不能放在循环执行的函数体内<br> <strong>解决方法：</strong>将其移到main()函数中。</p>
<p>再插入到二维Vector。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void create_TwoDimensional_vector(vector&lt;vector&lt;int&gt; &gt;&amp; obj,int number)&#x2F;&#x2F;建立二维随机Vector</span><br><span class="line">	&#123;</span><br><span class="line">		vector&lt;int&gt;b(number);&#x2F;&#x2F;声明大小为number的一维vector</span><br><span class="line">		for (int i &#x3D; 0; i &lt; b.size(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			createRamdomVector(b);&#x2F;&#x2F;调用函数，生成一维随机0，1的vector。</span><br><span class="line">			obj.push_back(b);&#x2F;&#x2F;插入到二维Vector中</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>得到索引值</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void getIndex(vector&lt;vector&lt;int&gt; &gt;&amp; obj, vector&lt;int&gt;&amp; xIndex,vector&lt;int&gt;&amp; yIndex)&#x2F;&#x2F;xIndex,yIndex</span><br><span class="line">	&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; obj.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; obj[0].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                int indexValue &#x3D; obj[i][j];</span><br><span class="line">                if (indexValue &#x3D;&#x3D; 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    xIndex.push_back(i);</span><br><span class="line">                    yIndex.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><em>声明全局变量方向数组dx，dy，以及计数器counter。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1 &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><em>changeVector，将1周围（上、下、左、右）的0都变为0。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void changeVector(vector&lt;vector&lt;int&gt; &gt;&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; xIndex;</span><br><span class="line">        vector&lt;int&gt; yIndex;</span><br><span class="line">        getIndex(obj, xIndex, yIndex);</span><br><span class="line">		int size&#x3D;obj.size();</span><br><span class="line">        </span><br><span class="line">        for (int j &#x3D; 0; j &lt; xIndex.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 4; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                int x &#x3D; xIndex[j] + dx[i];</span><br><span class="line">                int y &#x3D; yIndex[j] + dy[i];</span><br><span class="line"></span><br><span class="line">                if ((x &lt; 0)||(x&gt;size-1))continue;</span><br><span class="line">                if ((y &lt; 0)||(y&gt;size-1))continue;</span><br><span class="line"></span><br><span class="line">                int indexValue &#x3D; obj[x][y];</span><br><span class="line">                if (indexValue &#x3D;&#x3D; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    obj[x][y] &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><em>循环执行changeVector，每执行一次counter加1，已知最大距离2×obj.size(),如果地图全为1，跳出循环。这里涉及到跳出双重循环，声明一个flag值。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxDistance(vector&lt; vector&lt;int&gt; &gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">	int counter &#x3D; 0;</span><br><span class="line">	vector&lt;vector&lt;int&gt; &gt;::iterator iter;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; ( 2 * obj.size() ); ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		int flag &#x3D; 0;</span><br><span class="line">		for (iter &#x3D; obj.begin(); iter !&#x3D; obj.end(); ++iter)</span><br><span class="line">		&#123;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; (*iter).size(); ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				if ((*iter)[i] &#x3D;&#x3D; 0)</span><br><span class="line">				&#123;</span><br><span class="line">					flag &#x3D; 1;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (flag &#x3D;&#x3D; 1)break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag &#x3D;&#x3D; 1)</span><br><span class="line">		&#123;</span><br><span class="line">			changeVector(obj);</span><br><span class="line">			cout &lt;&lt;endl&lt;&lt;counter+1 &lt;&lt; &quot;change:&quot; &lt;&lt;endl;</span><br><span class="line">			output_TwoDimensional_vector(obj);</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			counter +&#x3D; 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else break;&#x2F;&#x2F;全为1时跳出。	</span><br><span class="line">	&#125;	</span><br><span class="line">	return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><em>其它辅助函数,输出二维数组，方便中途观察地图变化。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void output_TwoDimensional_vector(vector&lt;vector&lt;int&gt; &gt;&amp; a)&#x2F;&#x2F;输出二维vector</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Vector:&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;迭代器输出</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt;::iterator iter;</span><br><span class="line">        for (iter &#x3D; a.begin(); iter !&#x3D; a.end(); ++iter)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; (*iter).size(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; (*iter)[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">        &#x2F;&#x2F;数组索引输出</span><br><span class="line">          for (int i &#x3D; 0; i &lt; a.size(); ++i)</span><br><span class="line">          &#123;</span><br><span class="line">              for (int j &#x3D; 0; j &lt; a[0].size(); ++j)</span><br><span class="line">              &#123;</span><br><span class="line">                  cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">              &#125;</span><br><span class="line">              cout &lt;&lt; endl;</span><br><span class="line">          &#125;</span><br><span class="line">        *&#x2F;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><em>main函数</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	srand((int)(time(NULL)));&#x2F;&#x2F;生成时间种子</span><br><span class="line">	vector&lt;vector&lt;int&gt; &gt;a;</span><br><span class="line">	create_TwoDimensional_vector(a,10);</span><br><span class="line">	output_TwoDimensional_vector(a);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;maxDistance is:&quot; &lt;&lt; maxDistance(a);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="调试结果"><a href="#调试结果" class="headerlink" title="调试结果"></a>调试结果</h1><p>4×4地图：<br><img src="/images/pasted-0.png" alt="upload successful"></p>
<p>10×10地图：<br><img src="/images/pasted-14.png" alt="upload successful"></p>
<hr>
<h1 id="涉及知识"><a href="#涉及知识" class="headerlink" title="涉及知识"></a>涉及知识</h1><ul>
<li>vector使用（迭代器），二维Vector的建立</li>
<li>srand随机数</li>
<li>跳出双重循环</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Vector</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title>LL(1)文法</title>
    <url>/2020/04/28/LL(1)/</url>
    <content><![CDATA[<h1 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h1><p>课程回放“自顶向下文法分析”，时间40:00</p>
<ul>
<li>对《编译技术》课程<strong>第四章作业</strong>的解析</li>
</ul>
<hr>
<h2 id="作业实例"><a href="#作业实例" class="headerlink" title="作业实例"></a>作业实例</h2><p>文法：G：S&rarr;SS+|SS*|a</p>
<h3 id="提取左因子"><a href="#提取左因子" class="headerlink" title="提取左因子:"></a>提取左因子:</h3><p>S&rarr;SA|a<br>A&rarr;SC<br>C&rarr;+|*</p>
<h3 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h3><p>S&rarr;aB<br>B&rarr;AB|$\varepsilon$<br>A&rarr;SC<br>C&rarr;+|*</p>
<h3 id="求First集"><a href="#求First集" class="headerlink" title="求First集"></a>求First集</h3><p>First(S)={a}<br>First(A)={a}<br>First(B)={a,$\varepsilon$}<br>First(C)={+,* }</p>
<h3 id="求Follow集"><a href="#求Follow集" class="headerlink" title="求Follow集"></a>求Follow集</h3><p><strong>Follow集求法的一般规则</strong></p>
<ol>
<li>对于S开始符号，Follow(S)={$}</li>
<li>如果存在一个产生式A&rarr;$\alpha$B$\beta$,则First($\beta$)除去{$\varepsilon$}之外的所有符号都在Follow(B)中。</li>
<li>如果存在一个产生式A&rarr;$\alpha$B,或者存在产生式A&rarr;$\alpha$B$\beta$，并且First($\beta$)中包含$\varepsilon$，那么Follow(A)的符号都在Follow(B)中。</li>
</ol>
<p><strong>问题求解过程</strong></p>
<ol>
<li>Follow(S)，根据A&rarr;SC，First(C)填入{+,*,$}</li>
<li>Follow(A)，B&rarr;AB,First(B)填入；</li>
<li>Follow(B),<br>&rArr;B&rarr;AB<br>&rArr;AB&rarr;AAB<br>&rArr;A&rarr;SC，S&rarr;aB代入，AB&rarr;ASCB&rarr;AaBCB<br>所以，Follow(B)=First(C)-{$\varepsilon$}={+,* } $\cup$ {$}</li>
<li>AB&rarr;ASCB&rarr;AaBCB, Follow(C)=First(B)-{$\varepsilon$}={a}<br>根据<strong>一般规则3.</strong>, First(B)包含$\varepsilon$，所以Follow(B)包含在Follow(C)中</li>
</ol>
<p><strong>Follow集</strong><br>Follow(S)={+,*,$}</p>
<p>Follow(A)={a,$}</p>
<p>Follow(B)={+,* ,$}</p>
<p>Follow(C)={a,+,* ,$}</p>
<h3 id="判断是否是LL-1-文法"><a href="#判断是否是LL-1-文法" class="headerlink" title="判断是否是LL(1)文法"></a>判断是否是LL(1)文法</h3><p>根据龙书，一个文法G是LL(1)文法，当且仅当对于G的每个非终结符Α的任何两个不同产生式<br>Α→α,Α→β均满足下面条件(其中α和β不能同时推出ε):<br>1、FIRST(α)∩FIRST(β)=Φ<br>2、假若β=&gt;* ε，那么FIRST(α)∩FOLLOW(A)＝Φ</p>
<p><img src="/images/pasted-18.png" alt="upload successful"></p>
<h3 id="构建LL-1-分析表"><a href="#构建LL-1-分析表" class="headerlink" title="构建LL(1)分析表"></a>构建LL(1)分析表</h3><p>对应PPT<br><img src="/images/pasted-15.png" alt="upload successful"><br><img src="/images/pasted-16.png" alt="upload successful"></p>
<h3 id="LL-1-分析过程模拟"><a href="#LL-1-分析过程模拟" class="headerlink" title="LL(1)分析过程模拟"></a>LL(1)分析过程模拟</h3><p>PPT的例子：<br><img src="/images/pasted-17.png" alt="upload successful"></p>
]]></content>
      <categories>
        <category>编译技术</category>
      </categories>
      <tags>
        <tag>作业</tag>
        <tag>LL(1)</tag>
      </tags>
  </entry>
  <entry>
    <title>非对称加密SM2和ECDSA/[IDEA] java实现SM2加解密 </title>
    <url>/2021/06/04/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA/%5BIDEA%5D%20java%E5%AE%9E%E7%8E%B0SM2%E5%8A%A0%E8%A7%A3%E5%AF%86%20/</url>
    <content><![CDATA[<h1 id="IDEA-java实现SM2加解密"><a href="#IDEA-java实现SM2加解密" class="headerlink" title="[IDEA] java实现SM2加解密"></a>[IDEA] java实现SM2加解密</h1><h2 id="1-密码库bouncycastle配置"><a href="#1-密码库bouncycastle配置" class="headerlink" title="1. 密码库bouncycastle配置"></a>1. 密码库bouncycastle配置</h2><p><a href="%5BIDEA%5D%20java%E5%AE%9E%E7%8E%B0SM2%E5%8A%A0%E8%A7%A3%E5%AF%86%202b6a5d9fd60744aca44fd4142a79bc60/windows%E7%B3%BB%E7%BB%9F%E6%B7%BB%E5%8A%A0bc%E5%88%B0IDEA%2024971ff07e164d3499d84760186fda30.md">windows系统添加bc到IDEA</a></p>
<h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><p><a href="%5BIDEA%5D%20java%E5%AE%9E%E7%8E%B0SM2%E5%8A%A0%E8%A7%A3%E5%AF%86%202b6a5d9fd60744aca44fd4142a79bc60/SM2%20java%20140e16351cce402887c2a2c6d7a140ce.md">SM2.java</a></p>
<p><a href="%5BIDEA%5D%20java%E5%AE%9E%E7%8E%B0SM2%E5%8A%A0%E8%A7%A3%E5%AF%86%202b6a5d9fd60744aca44fd4142a79bc60/SM2KeyPair%20java%2024c54867efee44529af88d471943d43b.md">SM2KeyPair.java</a></p>
<p><a href="%5BIDEA%5D%20java%E5%AE%9E%E7%8E%B0SM2%E5%8A%A0%E8%A7%A3%E5%AF%86%202b6a5d9fd60744aca44fd4142a79bc60/Test%20java%200375a5c5383f453e839da9e177725c84.md">Test.java</a></p>
<h2 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3.运行结果"></a>3.运行结果</h2><p><img src="%5BIDEA%5D%20java%E5%AE%9E%E7%8E%B0SM2%E5%8A%A0%E8%A7%A3%E5%AF%86%202b6a5d9fd60744aca44fd4142a79bc60/Untitled.png" alt="%5BIDEA%5D%20java%E5%AE%9E%E7%8E%B0SM2%E5%8A%A0%E8%A7%A3%E5%AF%86%202b6a5d9fd60744aca44fd4142a79bc60/Untitled.png"></p>
]]></content>
  </entry>
  <entry>
    <title>非对称加密SM2和ECDSA/非对称加密SM2和ECDSA</title>
    <url>/2021/06/04/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA/</url>
    <content><![CDATA[<h1 id="非对称加密SM2和ECDSA"><a href="#非对称加密SM2和ECDSA" class="headerlink" title="非对称加密SM2和ECDSA"></a>非对称加密SM2和ECDSA</h1><h2 id="非对称加解密"><a href="#非对称加解密" class="headerlink" title="非对称加解密"></a>非对称加解密</h2><p>如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。</p>
<h1 id="SM２"><a href="#SM２" class="headerlink" title="SM２"></a>SM２</h1><p>数字签名（又称公钥数字签名）是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。它是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术来实现的，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。数字签名是非对称密钥加密技术与数字摘要技术的应用。</p>
<p>签名流程</p>
<p><img src="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA%20d9740bddc29b428d9a6e05e269dd1feb/Untitled.png" alt="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA%20d9740bddc29b428d9a6e05e269dd1feb/Untitled.png"></p>
<p>验收流程</p>
<p><img src="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA%20d9740bddc29b428d9a6e05e269dd1feb/Untitled%201.png" alt="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA%20d9740bddc29b428d9a6e05e269dd1feb/Untitled%201.png"></p>
<p>加密</p>
<p><img src="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA%20d9740bddc29b428d9a6e05e269dd1feb/Untitled%202.png" alt="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA%20d9740bddc29b428d9a6e05e269dd1feb/Untitled%202.png"></p>
<p>解密</p>
<p><img src="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA%20d9740bddc29b428d9a6e05e269dd1feb/Untitled%203.png" alt="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA%20d9740bddc29b428d9a6e05e269dd1feb/Untitled%203.png"></p>
<p><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA%20d9740bddc29b428d9a6e05e269dd1feb/SM2.pdf">SM2公钥密码加密.pdf</a></p>
<p><a href="%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA%20d9740bddc29b428d9a6e05e269dd1feb/%5BIDEA%5D%20java%E5%AE%9E%E7%8E%B0SM2%E5%8A%A0%E8%A7%A3%E5%AF%86%202b6a5d9fd60744aca44fd4142a79bc60.md">[IDEA] java实现SM2加解密</a></p>
]]></content>
  </entry>
  <entry>
    <title>非对称加密SM2和ECDSA/[IDEA] java实现SM2加解密/SM2 java</title>
    <url>/2021/06/04/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA/%5BIDEA%5D%20java%E5%AE%9E%E7%8E%B0SM2%E5%8A%A0%E8%A7%A3%E5%AF%86/SM2%20java/</url>
    <content><![CDATA[<h1 id="SM2-java"><a href="#SM2-java" class="headerlink" title="SM2.java"></a>SM2.java</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SM2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.crypto.DerivationFunction;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.crypto.digests.SHA256Digest;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.crypto.digests.ShortenedDigest;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.crypto.generators.KDF1BytesGenerator;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.crypto.params.ISO18033KDFParameters;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.math.ec.ECCurve;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.math.ec.ECPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SM2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 素数p */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigInteger p = <span class="keyword">new</span> BigInteger(<span class="string">"FFFFFFFE"</span> + <span class="string">"FFFFFFFF"</span></span><br><span class="line">            + <span class="string">"FFFFFFFF"</span> + <span class="string">"FFFFFFFF"</span> + <span class="string">"FFFFFFFF"</span> + <span class="string">"00000000"</span> + <span class="string">"FFFFFFFF"</span></span><br><span class="line">            + <span class="string">"FFFFFFFF"</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 系数a */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"FFFFFFFE"</span> + <span class="string">"FFFFFFFF"</span></span><br><span class="line">            + <span class="string">"FFFFFFFF"</span> + <span class="string">"FFFFFFFF"</span> + <span class="string">"FFFFFFFF"</span> + <span class="string">"00000000"</span> + <span class="string">"FFFFFFFF"</span></span><br><span class="line">            + <span class="string">"FFFFFFFC"</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 系数b */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"28E9FA9E"</span> + <span class="string">"9D9F5E34"</span></span><br><span class="line">            + <span class="string">"4D5A9E4B"</span> + <span class="string">"CF6509A7"</span> + <span class="string">"F39789F5"</span> + <span class="string">"15AB8F92"</span> + <span class="string">"DDBCBD41"</span></span><br><span class="line">            + <span class="string">"4D940E93"</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 坐标x */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigInteger xg = <span class="keyword">new</span> BigInteger(<span class="string">"32C4AE2C"</span> + <span class="string">"1F198119"</span></span><br><span class="line">            + <span class="string">"5F990446"</span> + <span class="string">"6A39C994"</span> + <span class="string">"8FE30BBF"</span> + <span class="string">"F2660BE1"</span> + <span class="string">"715A4589"</span></span><br><span class="line">            + <span class="string">"334C74C7"</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 坐标y */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigInteger yg = <span class="keyword">new</span> BigInteger(<span class="string">"BC3736A2"</span> + <span class="string">"F4F6779C"</span></span><br><span class="line">            + <span class="string">"59BDCEE3"</span> + <span class="string">"6B692153"</span> + <span class="string">"D0A9877C"</span> + <span class="string">"C62A4740"</span> + <span class="string">"02DF32E5"</span></span><br><span class="line">            + <span class="string">"2139F0A0"</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 基点G, G=(xg,yg),其介记为n */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigInteger n = <span class="keyword">new</span> BigInteger(<span class="string">"FFFFFFFE"</span> + <span class="string">"FFFFFFFF"</span></span><br><span class="line">            + <span class="string">"FFFFFFFF"</span> + <span class="string">"FFFFFFFF"</span> + <span class="string">"7203DF6B"</span> + <span class="string">"21C6052B"</span> + <span class="string">"53BBF409"</span></span><br><span class="line">            + <span class="string">"39D54123"</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SecureRandom random = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">    <span class="keyword">private</span> ECCurve.Fp curve;</span><br><span class="line">    <span class="keyword">private</span> ECPoint G;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">printHexString</span><span class="params">(<span class="keyword">byte</span>[] b)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            String hex = Integer.toHexString(b[i] &amp; <span class="number">0xFF</span>);</span><br><span class="line">            <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">                builder.append(<span class="string">'0'</span>+hex);</span><br><span class="line">                hex = <span class="string">'0'</span> + hex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//			System.out.print(hex.toUpperCase());</span></span><br><span class="line">            System.out.print(hex.toUpperCase());</span><br><span class="line">            builder.append(hex);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigInteger <span class="title">random</span><span class="params">(BigInteger max)</span> </span>&#123;</span><br><span class="line">        BigInteger r = <span class="keyword">new</span> BigInteger(<span class="number">256</span>, random);</span><br><span class="line">        <span class="comment">// int count = 1;</span></span><br><span class="line">        <span class="keyword">while</span> (r.compareTo(max) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            r = <span class="keyword">new</span> BigInteger(<span class="number">128</span>, random);</span><br><span class="line">            <span class="comment">// count++;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println("count: " + count);</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">allZero</span><span class="params">(<span class="keyword">byte</span>[] buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input 待加密消息M</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[] 加密后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encrypt(String input, ECPoint publicKey) &#123;</span><br><span class="line">        System.out.println(<span class="string">"---加密---"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"publicKey is: "</span>+publicKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] inputBuffer = input.getBytes();</span><br><span class="line">        printHexString(inputBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1 产生随机数k，k属于[1, n-1] */</span></span><br><span class="line">        BigInteger k = random(n);</span><br><span class="line">        System.out.print(<span class="string">"随机数k: "</span>);</span><br><span class="line">        printHexString(k.toByteArray());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2 计算椭圆曲线点C1 = [k]G = (x1, y1) */</span></span><br><span class="line">        ECPoint C1 = G.multiply(k);</span><br><span class="line">        <span class="keyword">byte</span>[] C1Buffer = C1.getEncoded(<span class="keyword">false</span>);</span><br><span class="line">        System.out.print(<span class="string">"椭圆曲线点C1: "</span>);</span><br><span class="line">        printHexString(C1Buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 计算椭圆曲线点 S = [h]Pb * curve没有指定余因子，h为空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//			 BigInteger h = curve.getCofactor(); System.out.print("h: ");</span></span><br><span class="line">        <span class="comment">//			 printHexString(h.toByteArray()); if (publicKey != null) &#123; ECPoint</span></span><br><span class="line">        <span class="comment">//			 result = publicKey.multiply(h); if (!result.isInfinity()) &#123;</span></span><br><span class="line">        <span class="comment">//			 System.out.println("pass"); &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//			System.err.println("计算椭圆曲线点 S = [h]Pb失败"); return null; &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 4 计算 [k]PB = (x2, y2) */</span></span><br><span class="line">        ECPoint kpb = publicKey.multiply(k).normalize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 5 计算 t = KDF(x2||y2, klen) */</span></span><br><span class="line">        <span class="keyword">byte</span>[] kpbBytes = kpb.getEncoded(<span class="keyword">false</span>);</span><br><span class="line">        DerivationFunction kdf = <span class="keyword">new</span> KDF1BytesGenerator(<span class="keyword">new</span> ShortenedDigest(</span><br><span class="line">                <span class="keyword">new</span> SHA256Digest(), <span class="number">20</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] t = <span class="keyword">new</span> <span class="keyword">byte</span>[inputBuffer.length];</span><br><span class="line">        kdf.init(<span class="keyword">new</span> ISO18033KDFParameters(kpbBytes));</span><br><span class="line">        kdf.generateBytes(t, <span class="number">0</span>, t.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allZero(t)) &#123;</span><br><span class="line">            System.err.println(<span class="string">"all zero"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 6 计算C2=M^t */</span></span><br><span class="line">        <span class="keyword">byte</span>[] C2 = <span class="keyword">new</span> <span class="keyword">byte</span>[inputBuffer.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputBuffer.length; i++) &#123;</span><br><span class="line">            C2[i] = (<span class="keyword">byte</span>) (inputBuffer[i] ^ t[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 7 计算C3 = Hash(x2 || M || y2) */</span></span><br><span class="line">        <span class="keyword">byte</span>[] C3 = calculateHash(kpb.getXCoord().toBigInteger(), inputBuffer,</span><br><span class="line">                kpb.getYCoord().toBigInteger());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 8 输出密文 C=C1 || C2 || C3 */</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptResult = <span class="keyword">new</span> <span class="keyword">byte</span>[C1Buffer.length + C2.length + C3.length];</span><br><span class="line">        System.arraycopy(C1Buffer, <span class="number">0</span>, encryptResult, <span class="number">0</span>, C1Buffer.length);</span><br><span class="line">        System.arraycopy(C2, <span class="number">0</span>, encryptResult, C1Buffer.length, C2.length);</span><br><span class="line">        System.arraycopy(C3, <span class="number">0</span>, encryptResult, C1Buffer.length + C2.length,</span><br><span class="line">                C3.length);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"密文: "</span>);</span><br><span class="line">        printHexString(encryptResult);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> encryptResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrypt</span><span class="params">(<span class="keyword">byte</span>[] encryptData, BigInteger privateKey)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----解密-----"</span>);</span><br><span class="line">        System.out.println(<span class="string">"privateKey is: "</span>+privateKey);</span><br><span class="line">        System.out.println(<span class="string">"encryptData length: "</span> + encryptData.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] C1Byte = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">65</span>];</span><br><span class="line">        System.arraycopy(encryptData, <span class="number">0</span>, C1Byte, <span class="number">0</span>, C1Byte.length);</span><br><span class="line"></span><br><span class="line">        ECPoint C1 = curve.decodePoint(C1Byte).normalize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 计算[dB]C1 = (x2, y2) */</span></span><br><span class="line">        ECPoint dBC1 = C1.multiply(privateKey).normalize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 计算t = KDF(x2 || y2, klen) */</span></span><br><span class="line">        <span class="keyword">byte</span>[] dBC1Bytes = dBC1.getEncoded(<span class="keyword">false</span>);</span><br><span class="line">        DerivationFunction kdf = <span class="keyword">new</span> KDF1BytesGenerator(<span class="keyword">new</span> ShortenedDigest(</span><br><span class="line">                <span class="keyword">new</span> SHA256Digest(), <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> klen = encryptData.length - <span class="number">65</span> - <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">"klen = "</span> + klen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] t = <span class="keyword">new</span> <span class="keyword">byte</span>[klen];</span><br><span class="line">        kdf.init(<span class="keyword">new</span> ISO18033KDFParameters(dBC1Bytes));</span><br><span class="line">        kdf.generateBytes(t, <span class="number">0</span>, t.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allZero(t)) &#123;</span><br><span class="line">            System.err.println(<span class="string">"all zero"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 5 计算M'=C2^t */</span></span><br><span class="line">        <span class="keyword">byte</span>[] M = <span class="keyword">new</span> <span class="keyword">byte</span>[klen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">            M[i] = (<span class="keyword">byte</span>) (encryptData[C1Byte.length + i] ^ t[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 6 计算 u = Hash(x2 || M' || y2) 判断 u == C3是否成立 */</span></span><br><span class="line">        <span class="keyword">byte</span>[] C3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        System.arraycopy(encryptData, encryptData.length - <span class="number">20</span>, C3, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] u = calculateHash(dBC1.getXCoord().toBigInteger(), M, dBC1</span><br><span class="line">                .getYCoord().toBigInteger());</span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(u, C3)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"解密成功"</span>);</span><br><span class="line">            System.out.println(<span class="string">"元信息 = "</span> + <span class="keyword">new</span> String(M));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">"u = "</span>);</span><br><span class="line">            printHexString(u);</span><br><span class="line">            System.out.print(<span class="string">"C3 = "</span>);</span><br><span class="line">            printHexString(C3);</span><br><span class="line">            System.err.println(<span class="string">"解密验证失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] calculateHash(BigInteger x2, <span class="keyword">byte</span>[] M, BigInteger y2) &#123;</span><br><span class="line">        ShortenedDigest digest = <span class="keyword">new</span> ShortenedDigest(<span class="keyword">new</span> SHA256Digest(), <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] buf = x2.toByteArray();</span><br><span class="line">        digest.update(buf, <span class="number">0</span>, buf.length);</span><br><span class="line">        digest.update(M, <span class="number">0</span>, M.length);</span><br><span class="line">        buf = y2.toByteArray();</span><br><span class="line">        digest.update(buf, <span class="number">0</span>, buf.length);</span><br><span class="line"></span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        digest.doFinal(buf, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">between</span><span class="params">(BigInteger param, BigInteger min, BigInteger max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (param.compareTo(min) &gt;= <span class="number">0</span> &amp;&amp; param.compareTo(max) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥校验</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean true或false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPublicKey</span><span class="params">(ECPoint publicKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!publicKey.isInfinity()) &#123;</span><br><span class="line">            BigInteger x = publicKey.getXCoord().toBigInteger();</span><br><span class="line">            BigInteger y = publicKey.getYCoord().toBigInteger();</span><br><span class="line">            <span class="keyword">if</span> (between(x, <span class="keyword">new</span> BigInteger(<span class="string">"0"</span>), p) &amp;&amp; between(y, <span class="keyword">new</span> BigInteger(<span class="string">"0"</span>), p)) &#123;</span><br><span class="line">                BigInteger xResult = x.pow(<span class="number">3</span>).add(a.multiply(x)).add(b).mod(p);</span><br><span class="line">                System.out.println(<span class="string">"xResult: "</span> + xResult.toString());</span><br><span class="line">                BigInteger yResult = y.pow(<span class="number">2</span>).mod(p);</span><br><span class="line">                System.out.println(<span class="string">"yResult: "</span> + yResult.toString());</span><br><span class="line">                <span class="keyword">if</span> (yResult.equals(xResult) &amp;&amp; publicKey.multiply(n).isInfinity()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得公私钥对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SM2KeyPair <span class="title">generateKeyPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInteger d = random(n.subtract(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>)));</span><br><span class="line">        SM2KeyPair keyPair = <span class="keyword">new</span> SM2KeyPair(G.multiply(d).normalize(), d);</span><br><span class="line">        <span class="keyword">if</span> (checkPublicKey(keyPair.getPublicKey())) &#123;</span><br><span class="line">            System.out.println(<span class="string">"generate key successfully"</span>);</span><br><span class="line">            <span class="keyword">return</span> keyPair;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">"generate key failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SM2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        curve = <span class="keyword">new</span> ECCurve.Fp(p, <span class="comment">// q</span></span><br><span class="line">                a, <span class="comment">// a</span></span><br><span class="line">                b); <span class="comment">// b</span></span><br><span class="line">        G = curve.createPoint(xg, yg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>非对称加密SM2和ECDSA/[IDEA] java实现SM2加解密/SM2KeyPair java</title>
    <url>/2021/06/04/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA/%5BIDEA%5D%20java%E5%AE%9E%E7%8E%B0SM2%E5%8A%A0%E8%A7%A3%E5%AF%86/SM2KeyPair%20java/</url>
    <content><![CDATA[<h1 id="SM2KeyPair-java"><a href="#SM2KeyPair-java" class="headerlink" title="SM2KeyPair.java"></a>SM2KeyPair.java</h1><p>产生公私钥对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SM2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.math.ec.ECPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SM2KeyPair</span> </span>&#123;</span><br><span class="line"><span class="comment">/**公钥*/</span></span><br><span class="line"><span class="keyword">private</span>  ECPoint publicKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**私钥*/</span></span><br><span class="line"><span class="keyword">private</span> BigInteger privateKey;</span><br><span class="line"></span><br><span class="line">    SM2KeyPair(ECPoint publicKey, BigInteger privateKey) &#123;</span><br><span class="line">        <span class="keyword">this</span>.publicKey = publicKey;</span><br><span class="line">        <span class="keyword">this</span>.privateKey = privateKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ECPoint <span class="title">getPublicKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> publicKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigInteger <span class="title">getPrivateKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>非对称加密SM2和ECDSA/[IDEA] java实现SM2加解密/Test java</title>
    <url>/2021/06/04/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA/%5BIDEA%5D%20java%E5%AE%9E%E7%8E%B0SM2%E5%8A%A0%E8%A7%A3%E5%AF%86/Test%20java/</url>
    <content><![CDATA[<h1 id="Test-java"><a href="#Test-java" class="headerlink" title="Test.java"></a>Test.java</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SM2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**元消息串*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> StringM= <span class="string">"刘聪平"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SM2 sm2 = <span class="keyword">new</span> SM2();</span><br><span class="line">        SM2KeyPair keyPair = sm2.generateKeyPair();</span><br><span class="line">        <span class="keyword">byte</span>[] data = sm2.encrypt(M,keyPair.getPublicKey());</span><br><span class="line">        System.out.println(<span class="string">"data is:"</span>+Arrays.toString(data));</span><br><span class="line">        sm2.decrypt(data, keyPair.getPrivateKey());<span class="comment">//71017045908707391874054405929626258767106914144911649587813342322113806533034</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>非对称加密SM2和ECDSA/[IDEA] java实现SM2加解密/windows系统添加bc到IDEA </title>
    <url>/2021/06/04/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86SM2%E5%92%8CECDSA/%5BIDEA%5D%20java%E5%AE%9E%E7%8E%B0SM2%E5%8A%A0%E8%A7%A3%E5%AF%86/windows%E7%B3%BB%E7%BB%9F%E6%B7%BB%E5%8A%A0bc%E5%88%B0IDEA%20/</url>
    <content><![CDATA[<h1 id="windows系统添加bc到IDEA"><a href="#windows系统添加bc到IDEA" class="headerlink" title="windows系统添加bc到IDEA"></a>windows系统添加bc到IDEA</h1><p>Bouncycastle是一个Java的密码库，因为加入了jdk的第三方安全库，在使用的时候需要进行配置。</p>
<p>下载链接：<a href="https://www.bouncycastle.org/latest_releases.html" target="_blank" rel="noopener">https://www.bouncycastle.org/latest_releases.html</a></p>
<p>下载完bcprov-jdk15on-168.jar包后。</p>
<h3 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h3><ol>
<li>找到Java的安装目录。例如：C:\ProgramFiles\Java\jdk1.8.0_38\jre\lib\ext目录下，把bcprov-jdk15on-168.jar文件放于其中。</li>
<li>安全属性文件java.security位于和/lib/ext平行的另一个目录/lib/security下，它定义了当前可以使用的加密提供者。找到provider编辑位置，添加下面字段，修改x为具体的序号。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security.provider.x&#x3D;org.bouncycastle.jce.provider.BouncyCastleProvider</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>IDEA中：点击 File -&gt; Project Structure（快捷键 Ctrl + Alt + Shift + s），点击Project Structure界面左侧的“Modules”显示下图界面；在 “Dependencies” 标签界面下，点击右边绿色的 “+”号，选择第一个选项“JARs or directories…”，选择相应的jar包，点“OK”，jar包添加成功。</li>
</ol>
]]></content>
  </entry>
</search>
